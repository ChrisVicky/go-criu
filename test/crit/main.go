package main

import (
	"bytes"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/checkpoint-restore/go-criu/v6/crit"
	"github.com/checkpoint-restore/go-criu/v6/crit/cli"
	"github.com/checkpoint-restore/go-criu/v6/crit/images/pstree"
)

const testImgDir = "test-imgs"

func main() {
	// Get list of image files
	imgs, err := getImgs()
	if err != nil {
		log.Fatal(err)
	}
	// Run recode test
	if err = recodeImgs(imgs); err != nil {
		log.Fatal(err)
	}

	// Run test for memory pages reading features
	if err = readMemoryPages(); err != nil {
		log.Fatal(err)
	}
	log.Println("=== PASS")
}

func recodeImgs(imgs []string) error {
	for _, img := range imgs {
		log.Println("===", img)
		imgFile, err := os.Open(img)
		if err != nil {
			return err
		}
		defer imgFile.Close()
		testImg := fmt.Sprintf("%s.test.img", img)
		testImgFile, err := os.Create(testImg)
		if err != nil {
			return err
		}
		defer testImgFile.Close()

		c := crit.New(imgFile, testImgFile, "", false, false)
		entryType, err := cli.GetEntryTypeFromImg(imgFile)
		if err != nil {
			return err
		}
		// Decode the binary image file
		decodedImg, err := c.Decode(entryType)
		if err != nil {
			return errors.New(fmt.Sprint("[DECODE]: ", err))
		}
		// Encode it into test binary image file
		if err = c.Encode(decodedImg); err != nil {
			return errors.New(fmt.Sprint("[ENCODE]: ", err))
		}
		// Open and compare original and test files
		imgBytes, err := os.ReadFile(img)
		if err != nil {
			return err
		}
		testImgBytes, err := os.ReadFile(testImg)
		if err != nil {
			return err
		}
		if !bytes.Equal(imgBytes, testImgBytes) {
			return errors.New("[RECODE]: Files do not match")
		}
	}

	return nil
}

func getImgs() ([]string, error) {
	// Certain image files generated by CRIU do not
	// use the protobuf format and contain raw binary
	// data. Some image files are also generated using
	// external tools (ifaddr, route, tmpfs). As these
	// images cannot be processed by CRIT, they are
	// excluded from the tests.
	skipImgs := []string{
		"pages-",
		"pages-shmem-",
		"iptables-",
		"ip6tables-",
		"nftables-",
		"route-",
		"route6-",
		"ifaddr-",
		"tmpfs-",
		"tmpfs-dev-",
		"autofs-",
		"netns-ct-",
		"netns-exp-",
		"rule-",
	}
	// "*.test.img", "*.json.img" or "tmp.*.img" files
	// must be skipped as they are generated by tests
	criuImg := regexp.MustCompile(`^[^\.]*\.img$`)
	dir, err := filepath.Glob(fmt.Sprintf("%s/*.img", testImgDir))
	if err != nil {
		return nil, err
	}
	var imgs []string

nextFile:
	for _, file := range dir {
		if filepath.Ext(file) == ".img" {
			if !criuImg.MatchString(file) {
				continue
			}
			for _, skip := range skipImgs {
				if strings.HasPrefix(filepath.Base(file), skip) {
					continue nextFile
				}
			}
			imgs = append(imgs, file)
		}
	}

	return imgs, nil
}

// readMemoryPages reads and compares process arguments
// and environment variables from memory pages and corresponding test files.
func readMemoryPages() error {
	psTreeFile, err := os.Open(filepath.Join(testImgDir, "pstree.img"))
	if err != nil {
		return err
	}
	defer psTreeFile.Close()

	c := crit.New(psTreeFile, nil, testImgDir, false, true)

	psTreeImg, err := c.Decode(&pstree.PstreeEntry{})
	if err != nil {
		return err
	}

	pid := psTreeImg.Entries[0].Message.(*pstree.PstreeEntry).GetPid()

	mr, err := crit.NewMemoryReader(testImgDir, pid, os.Getpagesize())
	if err != nil {
		return err
	}

	// Retrieve process arguments from memory pages
	argsBuff, err := mr.GetPsArgs()
	if err != nil {
		return err
	}

	// Read process environment variables from the environ test file
	testFileArgs, err := ioutil.ReadFile(filepath.Join(testImgDir, "cmdline"))
	if err != nil {
		return err
	}

	if !bytes.Equal(testFileArgs, argsBuff.Bytes()) {
		return errors.New("process arguments do not match")
	}

	// Retrieve process environment variables from memory pages
	envVarsBuffer, err := mr.GetPsEnvVars()
	if err != nil {
		return err
	}

	// Read process environment variables from the environ test file
	envVarsTestFile, err := ioutil.ReadFile(filepath.Join(testImgDir, "environ"))
	if err != nil {
		return err
	}

	if !bytes.Equal(envVarsTestFile, envVarsBuffer.Bytes()) {
		return errors.New("process environment variables do not match")
	}

	return nil
}
