package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

func main() {
	// check arguments
	if len(os.Args) != 3 {
		fmt.Println("Usage: magicgen.go path/to/magic.h path/to/magic.go")
		return
	}

	magicHPath := os.Args[1]
	magicGoPath := os.Args[2]
	// open magic.h
	magicHFile, err := os.Open(magicHPath)
	if err != nil {
		fmt.Println("Failed to open magic.h")
		return
	}
	defer magicHFile.Close()
	// open magic.json if it exists, else create it
	magicGoFile, err := os.OpenFile(magicGoPath, os.O_WRONLY|os.O_CREATE, 0o644)
	if err != nil {
		fmt.Println("Failed to open magic.go")
		return
	}
	defer magicGoFile.Close()

	magics := make(map[string]string)

	r := bufio.NewScanner(magicHFile)
	// scan the file line by line
	for r.Scan() {
		tokens := strings.Fields(r.Text())
		if len(tokens) >= 3 {
			if tokens[0] == "#define" {
				magicName := tokens[1]
				magicHex := tokens[2]
				// check if magic is defined as another magic
				if _, ok := magics[magicHex]; !ok {
					magics[magicName] = magicHex
				}
			}
		}
	}

	w := bufio.NewWriter(magicGoFile)
	fmt.Fprintf(w,
		`// Code generated by magicgen. DO NOT EDIT.

package magic

type MagicMap struct {
	ByName  map[string]uint64
	ByValue map[uint64]string
}

func LoadMagic() MagicMap {
	magicMap := MagicMap{
		ByName:  make(map[string]uint64),
		ByValue: make(map[uint64]string),
	}`)

	for k, v := range magics {
		if v == "0x0" || v == "1" || k == "0x0" {
			continue
		}
		if strings.Contains(k, "_MAGIC") == true {
			k = strings.Replace(k, "_MAGIC", "", -1)
		}
		/*
			Although the value of v above is a hex string,
			base 0 has to be used instead of base 16
			to convert without errors.As strconv.ParseUint
			outputs a invalid syntax error for strings that
			have 0x at the beginning when base 16 is given
			example -> https://play.golang.org/p/6dWo6oy9vyo
		*/
		magicHexInt, err := strconv.ParseUint(v, 0, 64)
		if err != nil {
			fmt.Printf("Failed to parse magic %s\n", k)
			continue
		}
		fmt.Fprintf(w, "\n\tmagicMap.ByName[\"%s\"] = %d",
			k, magicHexInt)
		fmt.Fprintf(w, "\n\tmagicMap.ByValue[%d] = \"%s\"",
			magicHexInt, k)
	}
	fmt.Fprintf(w, "\n\treturn magicMap\n}\n")
	w.Flush()
}
